# 1939 중량제한

---

## CODE

```python
import sys
from collections import deque

input = sys.stdin.readline

N, M = map(int, input().split())
g = [[] * (N + 1) for _ in range(N + 1)]
for _ in range(M):
    A, B, C = map(int, input().split())
    g[A].append((B, C))
    g[B].append((A, C))
START, GOAL = map(int, input().split())


# 풀이
def solve():
    global N, M, g, START, GOAL

    def bfs(start, weight):
        que = deque([start])
        v = [False] * (N + 1)
        v[start] = True
        while que:
            cur = que.popleft()
            if cur == GOAL:
                return True
            for nxt, limit in g[cur]:
                if weight <= limit and not v[nxt]:
                    que.append(nxt)
                    v[nxt] = True
        return False

    ans = 0
    l = 1
    r = 1_000_000_000
    while l <= r:
        mid = (l + r) // 2
        res = bfs(START, mid)
        if res:
            l = mid + 1
            ans = max(ans, mid)
        else:
            r = mid - 1

    print(ans)
    return


solve()

```

## 해설

1. 이분 탐색으로 중량의 값을 찾는다.
2. 해당 중량으로 시작 공장에서 끝 공장까지 BFS를 진행한다.
3. 경로가 연결 되면 최단 경로로 해당 중량을 옮길 수 있다.
4. 그 중량 값을 비교해서 이전에 성공했던 중량 값보다 크면 갱신한다.
5. 경로가 연결되지 않는다면 `right` 를 줄여 중량 값을 줄이고 다시 시행한다.
6. 반복하면 중량의 최댓값인 정답을 찾을 수 있다.

`56040KB`, `368ms`
