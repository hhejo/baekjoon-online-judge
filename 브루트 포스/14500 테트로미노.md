# 14500 테트로미노



### 접근방법

한 칸에 놓을 수 있는 모든 테트로미노를 생각했다. 각 테트로미노의 모든 대칭, 회전에 대해 좌상단을 기준으로 잡았다.

### CODE 1

```python
N, M = map(int, input().split())
MAP = [list(map(int, input().split())) for _ in range(N)]

Ds = (
    ((0, 0), (0, 1), (0, 2), (0, 3)),
    ((0, 0), (1, 0), (2, 0), (3, 0)),

    ((0, 0), (0, 1), (1, 0), (1, 1)),

    ((0, 0), (1, 0), (2, 0), (2, 1)),
    ((0, 0), (1, 0), (0, 1), (0, 2)),
    ((0, 0), (0, 1), (1, 1), (2, 1)),
    ((0, 0), (0, 1), (0, 2), (-1, 2)),
    ((0, 0), (0, 1), (-1, 1), (-2, 1)),
    ((0, 0), (1, 0), (1, 1), (1, 2)),
    ((0, 0), (0, 1), (1, 0), (2, 0)),
    ((0, 0), (0, 1), (0, 2), (1, 2)),

    ((0, 0), (1, 0), (1, 1), (2, 1)),
    ((0, 0), (0, 1), (-1, 1), (-1, 2)),
    ((0, 0), (1, 0), (1, -1), (2, -1)),
    ((0, 0), (0, 1), (1, 1), (1, 2)),

    ((0, 0), (0, 1), (0, 2), (1, 1)),
    ((0, 0), (1, 0), (2, 0), (1, 1)),
    ((0, 0), (0, 1), (0, 2), (-1, 1)),
    ((0, 0), (1, 0), (2, 0), (1, -1))
 )

vals = [0] * (N * M) * 19 * 4
for i in range(N):
    for j in range(M):
        for D in Ds:
            ci, cj = i, j
            val = 0
            for d in D:
                ni, nj = ci + d[0], cj + d[1]
                if ni < 0 or ni >= N or nj < 0 or nj >= M:
                    continue
                val += MAP[ni][nj]
            ans = max(ans, val)
print(ans)
```

### 해설

각 좌표에 대해 모든 테트로미노를 대입했다.



### CODE 2

```python
N, M = map(int, input().split())
MAP = [list(map(int, input().split())) for _ in range(N)]

Ds = (
    ((0, 0), (0, 1), (0, 2), (0, 3)),
    ((0, 0), (1, 0), (2, 0), (3, 0)),

    ((0, 0), (0, 1), (1, 0), (1, 1)),

    ((0, 0), (1, 0), (2, 0), (2, 1)),
    ((0, 0), (1, 0), (0, 1), (0, 2)),
    ((0, 0), (0, 1), (1, 1), (2, 1)),
    ((0, 0), (0, 1), (0, 2), (-1, 2)),
    ((0, 0), (0, 1), (-1, 1), (-2, 1)),
    ((0, 0), (1, 0), (1, 1), (1, 2)),
    ((0, 0), (0, 1), (1, 0), (2, 0)),
    ((0, 0), (0, 1), (0, 2), (1, 2)),

    ((0, 0), (1, 0), (1, 1), (2, 1)),
    ((0, 0), (0, 1), (-1, 1), (-1, 2)),
    ((0, 0), (1, 0), (1, -1), (2, -1)),
    ((0, 0), (0, 1), (1, 1), (1, 2)),

    ((0, 0), (0, 1), (0, 2), (1, 1)),
    ((0, 0), (1, 0), (2, 0), (1, 1)),
    ((0, 0), (0, 1), (0, 2), (-1, 1)),
    ((0, 0), (1, 0), (2, 0), (1, -1))
 )
ans = 0
vals = [0] * (N * M) * 19 * 4
for i in range(N):
    for j in range(M):
        tmp = [0] * 19
        for idx, D in enumerate(Ds):
            ci, cj = i, j
            val = 0
            for d in D:
                ni, nj = ci + d[0], cj + d[1]
                if ni < 0 or ni >= N or nj < 0 or nj >= M:
                    continue
                val += MAP[ni][nj]
            tmp[idx] = val
        ans = max(ans, *tmp)
print(ans)
```

### 해설

한 사이클 후 최댓값을 구했는데 오히려 더 오래 걸렸다.

