# 2839 설탕 배달



## 1.

### 접근 방법

다이나믹 프로그래밍 방식으로 풀었다. `dp[N]`은 `N`kg의 설탕을 옮기는 데에 필요한 봉지의 최솟값이다. `dp[3]`부터 `dp[20]` 까지 그려보니 규칙을 발견할 수 있었다.

### CODE

```python
N = int(input())
dp = [0] * 5001
dp[1] = dp[2] = dp[4] = -1
dp[3] = dp[5] = 1
for i in range(6, N + 1):
    if -1 == dp[i - 5]:
        if -1 == dp[i - 3]:
            dp[i] = -1
        else:
            dp[i] = dp[3] + dp[i-3]
    else:
        dp[i] = dp[5] + dp[i-5]
print(dp[N])
```

### 해설

`i`번째 설탕에서 5를 빼고 그 값으로 `dp` 리스트의 인덱스로 값을 찾아낸다. 그 값이 `-1`이면 다시 3을 빼본다. 그래도 `-1`이면 해당 값은 `-1`이 된다. 이에 해당하지 않으면 `dp[i]`의 값은 3이나 5를 뺀 값의 dp값과 dp 3이나 5의 값이 된다.



## 2.

### 접근 방법

어쨌든 5를 먼저 빼면 최솟값이 되기 때문에 그리디로 해결할 수 있을 것 같았다. `N`이 5의 배수가 될 때까지 계속 3을 빼는 방식으로 구현했다.

### CODE

```python
N = int(input())
n, cnt = N, 0
while n % 5:
    n -= 3
    cnt += 1
if n < 0:
    cnt = -1
else:
    cnt += n // 5
print(cnt)
```

### 해설

`n`이 5의 배수가 될 때까지 3을 뺀다. 반복문이 종료되면, `n`이 0보다 작거나 5의 배수인 경우이다. 0보다 작다면 설탕을 배달할 수 없고 5의 배수이면 5로 나눈 몫을 추가한다.

