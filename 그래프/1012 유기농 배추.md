# 1012 유기농 배추

---

### CODE 1

```python
import sys


# 풀이
def solve():
    global M, N, arr

    # dfs
    def dfs(y, x):
        stk = [(y, x)]  # 스택에 시작위치 넣고 시작
        visited[y][x] = True  # 해당 위치 방문 처리
        # 스택이 빌 때까지 반복
        while stk:
            cy, cx = stk.pop()  # 현재 위치
            # 현재 위치에 대해 다음에 이동할 상, 우, 하, 좌 위치
            for ny, nx in ((cy - 1, cx), (cy, cx + 1), (cy + 1, cx), (cy, cx - 1)):
                # 유효 범위 내, 배추 있음, 방문하지 않음
                if 0 <= ny < N and 0 <= nx < M and arr[ny][nx] == 1 and not visited[ny][nx]:
                    stk.append((ny, nx))  # 해당 위치로 이동
                    visited[ny][nx] = True  # 방문 처리
        return

    cnt = 0  # 배추흰지렁이 수
    visited = [[False] * M for _ in range(N)]  # 땅의 해당 위치 방문 여부
    # 세로, 가로 땅의 모든 위치에 대해 반복
    for sy in range(N):
        for sx in range(M):
            # 해당 위치에 배추가 있음, 방문하지 않음
            if arr[sy][sx] == 1 and not visited[sy][sx]:
                dfs(sy, sx)  # DFS
                cnt += 1  # 배추흰지렁이 누적
    # 정답 출력
    print(cnt)
    return


# 입력
T = int(sys.stdin.readline())  # 테스트 케이스

# 풀이
for _ in range(T):
    M, N, K = map(int, sys.stdin.readline().split(' '))  # 가로, 세로, 배추 위치 개수
    arr = [[0] * M for _ in range(N)]  # 땅
    # 배추 위치 개수만큼 반복
    for _ in range(K):
        X, Y = map(int, sys.stdin.readline().split(' '))  # 배추 위치
        arr[Y][X] = 1  # 배추 심기
    solve()

```

### 해설 1

DFS 이용. 모든 위치에 대해 DFS를 시작하는데, DFS를 시작할 수 있다면 일단 배추흰지렁이를 1 누적

---

### CODE 2

```python
import sys
from collections import deque

#############################
sys.stdin = open('input.txt')
#############################


# 풀이
def solve():
    global M, N, arr

    # bfs
    def bfs(y, x):
        que = deque([(y, x)])  # 큐에 시작위치 넣고 시작
        visited[y][x] = True  # 해당 위치 방문 처리
        # 큐가 빌 때까지 반복
        while que:
            cy, cx = que.popleft()  # 현재 위치
            # 현재 위치에 대해 다음에 이동할 상, 우, 하, 좌 위치
            for ny, nx in ((cy - 1, cx), (cy, cx + 1), (cy + 1, cx), (cy, cx - 1)):
                # 유효 범위 내, 배추 있음, 방문하지 않음
                if 0 <= ny < N and 0 <= nx < M and arr[ny][nx] == 1 and not visited[ny][nx]:
                    que.append((ny, nx))  # 해당 위치로 이동
                    visited[ny][nx] = True  # 방문 처리
        return

    cnt = 0  # 배추흰지렁이 수
    visited = [[False] * M for _ in range(N)]  # 땅의 해당 위치 방문 여부
    # 세로, 가로 땅의 모든 위치에 대해 반복
    for sy in range(N):
        for sx in range(M):
            # 해당 위치에 배추가 있음, 방문하지 않음
            if arr[sy][sx] == 1 and not visited[sy][sx]:
                bfs(sy, sx)  # BFS
                cnt += 1  # 배추흰지렁이 누적
    # 정답 출력
    print(cnt)
    return


# 입력
T = int(sys.stdin.readline())  # 테스트 케이스

# 풀이
for _ in range(T):
    M, N, K = map(int, sys.stdin.readline().split(' '))  # 가로, 세로, 배추 위치 개수
    arr = [[0] * M for _ in range(N)]  # 땅
    # 배추 위치 개수만큼 반복
    for _ in range(K):
        X, Y = map(int, sys.stdin.readline().split(' '))  # 배추 위치
        arr[Y][X] = 1  # 배추 심기
    solve()

```

### 해설 2

BFS 이용. DFS와 거의 동일
