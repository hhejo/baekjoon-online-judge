# [1012 μ κΈ°λ† λ°°μ¶”](https://www.acmicpc.net/problem/1012)

### π¥ 2

### λ¶„λ¥

- κ·Έλν”„ μ΄λ΅ 
- κ·Έλν”„ νƒμƒ‰
- λ„λΉ„ μ°μ„  νƒμƒ‰
- κΉμ΄ μ°μ„  νƒμƒ‰

### ν’€μ΄ λ‚ μ§

- 230215 μ
- 230318 ν† 

---

## CODE 1

```python
import sys


# ν’€μ΄
def solve():
    global M, N, arr

    # dfs
    def dfs(y, x):
        stk = [(y, x)]  # μ¤νƒμ— μ‹μ‘μ„μΉ λ„£κ³  μ‹μ‘
        visited[y][x] = True  # ν•΄λ‹Ή μ„μΉ λ°©λ¬Έ μ²λ¦¬
        # μ¤νƒμ΄ λΉ λ•κΉμ§€ λ°λ³µ
        while stk:
            cy, cx = stk.pop()  # ν„μ¬ μ„μΉ
            # ν„μ¬ μ„μΉμ— λ€ν•΄ λ‹¤μμ— μ΄λ™ν•  μƒ, μ°, ν•, μΆ μ„μΉ
            for ny, nx in ((cy - 1, cx), (cy, cx + 1), (cy + 1, cx), (cy, cx - 1)):
                # μ ν¨ λ²”μ„ λ‚΄, λ°°μ¶” μμ, λ°©λ¬Έν•μ§€ μ•μ
                if 0 <= ny < N and 0 <= nx < M and arr[ny][nx] == 1 and not visited[ny][nx]:
                    stk.append((ny, nx))  # ν•΄λ‹Ή μ„μΉλ΅ μ΄λ™
                    visited[ny][nx] = True  # λ°©λ¬Έ μ²λ¦¬
        return

    cnt = 0  # λ°°μ¶”ν°μ§€λ μ΄ μ
    visited = [[False] * M for _ in range(N)]  # λ•…μ ν•΄λ‹Ή μ„μΉ λ°©λ¬Έ μ—¬λ¶€
    # μ„Έλ΅, κ°€λ΅ λ•…μ λ¨λ“  μ„μΉμ— λ€ν•΄ λ°λ³µ
    for sy in range(N):
        for sx in range(M):
            # ν•΄λ‹Ή μ„μΉμ— λ°°μ¶”κ°€ μμ, λ°©λ¬Έν•μ§€ μ•μ
            if arr[sy][sx] == 1 and not visited[sy][sx]:
                dfs(sy, sx)  # DFS
                cnt += 1  # λ°°μ¶”ν°μ§€λ μ΄ λ„μ 
    # μ •λ‹µ μ¶λ ¥
    print(cnt)
    return


# μ…λ ¥
T = int(sys.stdin.readline())  # ν…μ¤νΈ μΌ€μ΄μ¤

# ν’€μ΄
for _ in range(T):
    M, N, K = map(int, sys.stdin.readline().split(' '))  # κ°€λ΅, μ„Έλ΅, λ°°μ¶” μ„μΉ κ°μ
    arr = [[0] * M for _ in range(N)]  # λ•…
    # λ°°μ¶” μ„μΉ κ°μλ§νΌ λ°λ³µ
    for _ in range(K):
        X, Y = map(int, sys.stdin.readline().split(' '))  # λ°°μ¶” μ„μΉ
        arr[Y][X] = 1  # λ°°μ¶” μ‹¬κΈ°
    solve()

```

## ν•΄μ„¤ 1

DFS μ΄μ©. λ¨λ“  μ„μΉμ— λ€ν•΄ DFSλ¥Ό μ‹μ‘ν•λ”λ°, DFSλ¥Ό μ‹μ‘ν•  μ μλ‹¤λ©΄ μΌλ‹¨ λ°°μ¶”ν°μ§€λ μ΄λ¥Ό 1 λ„μ 

---

## CODE 2

```python
import sys
from collections import deque

#############################
sys.stdin = open('input.txt')
#############################


# ν’€μ΄
def solve():
    global M, N, arr

    # bfs
    def bfs(y, x):
        que = deque([(y, x)])  # νμ— μ‹μ‘μ„μΉ λ„£κ³  μ‹μ‘
        visited[y][x] = True  # ν•΄λ‹Ή μ„μΉ λ°©λ¬Έ μ²λ¦¬
        # νκ°€ λΉ λ•κΉμ§€ λ°λ³µ
        while que:
            cy, cx = que.popleft()  # ν„μ¬ μ„μΉ
            # ν„μ¬ μ„μΉμ— λ€ν•΄ λ‹¤μμ— μ΄λ™ν•  μƒ, μ°, ν•, μΆ μ„μΉ
            for ny, nx in ((cy - 1, cx), (cy, cx + 1), (cy + 1, cx), (cy, cx - 1)):
                # μ ν¨ λ²”μ„ λ‚΄, λ°°μ¶” μμ, λ°©λ¬Έν•μ§€ μ•μ
                if 0 <= ny < N and 0 <= nx < M and arr[ny][nx] == 1 and not visited[ny][nx]:
                    que.append((ny, nx))  # ν•΄λ‹Ή μ„μΉλ΅ μ΄λ™
                    visited[ny][nx] = True  # λ°©λ¬Έ μ²λ¦¬
        return

    cnt = 0  # λ°°μ¶”ν°μ§€λ μ΄ μ
    visited = [[False] * M for _ in range(N)]  # λ•…μ ν•΄λ‹Ή μ„μΉ λ°©λ¬Έ μ—¬λ¶€
    # μ„Έλ΅, κ°€λ΅ λ•…μ λ¨λ“  μ„μΉμ— λ€ν•΄ λ°λ³µ
    for sy in range(N):
        for sx in range(M):
            # ν•΄λ‹Ή μ„μΉμ— λ°°μ¶”κ°€ μμ, λ°©λ¬Έν•μ§€ μ•μ
            if arr[sy][sx] == 1 and not visited[sy][sx]:
                bfs(sy, sx)  # BFS
                cnt += 1  # λ°°μ¶”ν°μ§€λ μ΄ λ„μ 
    # μ •λ‹µ μ¶λ ¥
    print(cnt)
    return


# μ…λ ¥
T = int(sys.stdin.readline())  # ν…μ¤νΈ μΌ€μ΄μ¤

# ν’€μ΄
for _ in range(T):
    M, N, K = map(int, sys.stdin.readline().split(' '))  # κ°€λ΅, μ„Έλ΅, λ°°μ¶” μ„μΉ κ°μ
    arr = [[0] * M for _ in range(N)]  # λ•…
    # λ°°μ¶” μ„μΉ κ°μλ§νΌ λ°λ³µ
    for _ in range(K):
        X, Y = map(int, sys.stdin.readline().split(' '))  # λ°°μ¶” μ„μΉ
        arr[Y][X] = 1  # λ°°μ¶” μ‹¬κΈ°
    solve()

```

## ν•΄μ„¤ 2

BFS μ΄μ©. DFSμ™€ κ±°μ λ™μΌ

---

## CODE 3

```python
import sys
from collections import deque

input = sys.stdin.readline


# ν’€μ΄
def solve():
    global N, M, g

    def bfs(sx, sy):
        que = deque([(sx, sy)])
        v[sx][sy] = True
        dx = (-1, 0, 1, 0)
        dy = (0, 1, 0, -1)
        while que:
            cx, cy = que.popleft()
            for i in range(4):
                nx = cx + dx[i]
                ny = cy + dy[i]
                if 0 <= nx < N and 0 <= ny < M and g[nx][ny] == 1 and not v[nx][ny]:
                    que.append((nx, ny))
                    v[nx][ny] = True
        return

    ans = 0
    v = [[False] * M for _ in range(N)]
    for x in range(N):
        for y in range(M):
            if g[x][y] == 1 and not v[x][y]:
                bfs(x, y)
                ans += 1
    print(ans)
    return


for test_case in range(int(input())):
    M, N, K = map(int, input().split())
    g = [[0] * M for _ in range(N)]
    for _ in range(K):
        X, Y = map(int, input().split())
        g[Y][X] = 1
    solve()

```

## ν•΄μ„¤ 3

`34192KB`, `76ms`
