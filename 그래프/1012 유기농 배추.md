# [1012 μ κΈ°λ† λ°°μ¶”](https://www.acmicpc.net/problem/1012)

### π¥ 2

### λ¶„λ¥

- κ·Έλν”„ μ΄λ΅ 
- κ·Έλν”„ νƒμƒ‰
- λ„λΉ„ μ°μ„  νƒμƒ‰
- κΉμ΄ μ°μ„  νƒμƒ‰

### ν’€μ΄ λ‚ μ§

- 230215 μ
- 230318 ν† 
- 230403 μ›”
- 230427 λ©
- 230616 κΈ
- 230628 μ

---

## CODE 1

```python
import sys


# ν’€μ΄
def solve():
    global M, N, arr

    # dfs
    def dfs(y, x):
        stk = [(y, x)]  # μ¤νƒμ— μ‹μ‘μ„μΉ λ„£κ³  μ‹μ‘
        visited[y][x] = True  # ν•΄λ‹Ή μ„μΉ λ°©λ¬Έ μ²λ¦¬
        # μ¤νƒμ΄ λΉ λ•κΉμ§€ λ°λ³µ
        while stk:
            cy, cx = stk.pop()  # ν„μ¬ μ„μΉ
            # ν„μ¬ μ„μΉμ— λ€ν•΄ λ‹¤μμ— μ΄λ™ν•  μƒ, μ°, ν•, μΆ μ„μΉ
            for ny, nx in ((cy - 1, cx), (cy, cx + 1), (cy + 1, cx), (cy, cx - 1)):
                # μ ν¨ λ²”μ„ λ‚΄, λ°°μ¶” μμ, λ°©λ¬Έν•μ§€ μ•μ
                if 0 <= ny < N and 0 <= nx < M and arr[ny][nx] == 1 and not visited[ny][nx]:
                    stk.append((ny, nx))  # ν•΄λ‹Ή μ„μΉλ΅ μ΄λ™
                    visited[ny][nx] = True  # λ°©λ¬Έ μ²λ¦¬
        return

    cnt = 0  # λ°°μ¶”ν°μ§€λ μ΄ μ
    visited = [[False] * M for _ in range(N)]  # λ•…μ ν•΄λ‹Ή μ„μΉ λ°©λ¬Έ μ—¬λ¶€
    # μ„Έλ΅, κ°€λ΅ λ•…μ λ¨λ“  μ„μΉμ— λ€ν•΄ λ°λ³µ
    for sy in range(N):
        for sx in range(M):
            # ν•΄λ‹Ή μ„μΉμ— λ°°μ¶”κ°€ μμ, λ°©λ¬Έν•μ§€ μ•μ
            if arr[sy][sx] == 1 and not visited[sy][sx]:
                dfs(sy, sx)  # DFS
                cnt += 1  # λ°°μ¶”ν°μ§€λ μ΄ λ„μ 
    # μ •λ‹µ μ¶λ ¥
    print(cnt)
    return


# μ…λ ¥
T = int(sys.stdin.readline())  # ν…μ¤νΈ μΌ€μ΄μ¤

# ν’€μ΄
for _ in range(T):
    M, N, K = map(int, sys.stdin.readline().split(' '))  # κ°€λ΅, μ„Έλ΅, λ°°μ¶” μ„μΉ κ°μ
    arr = [[0] * M for _ in range(N)]  # λ•…
    # λ°°μ¶” μ„μΉ κ°μλ§νΌ λ°λ³µ
    for _ in range(K):
        X, Y = map(int, sys.stdin.readline().split(' '))  # λ°°μ¶” μ„μΉ
        arr[Y][X] = 1  # λ°°μ¶” μ‹¬κΈ°
    solve()

```

## ν•΄μ„¤ 1

DFS μ΄μ©. λ¨λ“  μ„μΉμ— λ€ν•΄ DFSλ¥Ό μ‹μ‘ν•λ”λ°, DFSλ¥Ό μ‹μ‘ν•  μ μλ‹¤λ©΄ μΌλ‹¨ λ°°μ¶”ν°μ§€λ μ΄λ¥Ό 1 λ„μ 

---

## CODE 2

```python
import sys
from collections import deque

#############################
sys.stdin = open('input.txt')
#############################


# ν’€μ΄
def solve():
    global M, N, arr

    # bfs
    def bfs(y, x):
        que = deque([(y, x)])  # νμ— μ‹μ‘μ„μΉ λ„£κ³  μ‹μ‘
        visited[y][x] = True  # ν•΄λ‹Ή μ„μΉ λ°©λ¬Έ μ²λ¦¬
        # νκ°€ λΉ λ•κΉμ§€ λ°λ³µ
        while que:
            cy, cx = que.popleft()  # ν„μ¬ μ„μΉ
            # ν„μ¬ μ„μΉμ— λ€ν•΄ λ‹¤μμ— μ΄λ™ν•  μƒ, μ°, ν•, μΆ μ„μΉ
            for ny, nx in ((cy - 1, cx), (cy, cx + 1), (cy + 1, cx), (cy, cx - 1)):
                # μ ν¨ λ²”μ„ λ‚΄, λ°°μ¶” μμ, λ°©λ¬Έν•μ§€ μ•μ
                if 0 <= ny < N and 0 <= nx < M and arr[ny][nx] == 1 and not visited[ny][nx]:
                    que.append((ny, nx))  # ν•΄λ‹Ή μ„μΉλ΅ μ΄λ™
                    visited[ny][nx] = True  # λ°©λ¬Έ μ²λ¦¬
        return

    cnt = 0  # λ°°μ¶”ν°μ§€λ μ΄ μ
    visited = [[False] * M for _ in range(N)]  # λ•…μ ν•΄λ‹Ή μ„μΉ λ°©λ¬Έ μ—¬λ¶€
    # μ„Έλ΅, κ°€λ΅ λ•…μ λ¨λ“  μ„μΉμ— λ€ν•΄ λ°λ³µ
    for sy in range(N):
        for sx in range(M):
            # ν•΄λ‹Ή μ„μΉμ— λ°°μ¶”κ°€ μμ, λ°©λ¬Έν•μ§€ μ•μ
            if arr[sy][sx] == 1 and not visited[sy][sx]:
                bfs(sy, sx)  # BFS
                cnt += 1  # λ°°μ¶”ν°μ§€λ μ΄ λ„μ 
    # μ •λ‹µ μ¶λ ¥
    print(cnt)
    return


# μ…λ ¥
T = int(sys.stdin.readline())  # ν…μ¤νΈ μΌ€μ΄μ¤

# ν’€μ΄
for _ in range(T):
    M, N, K = map(int, sys.stdin.readline().split(' '))  # κ°€λ΅, μ„Έλ΅, λ°°μ¶” μ„μΉ κ°μ
    arr = [[0] * M for _ in range(N)]  # λ•…
    # λ°°μ¶” μ„μΉ κ°μλ§νΌ λ°λ³µ
    for _ in range(K):
        X, Y = map(int, sys.stdin.readline().split(' '))  # λ°°μ¶” μ„μΉ
        arr[Y][X] = 1  # λ°°μ¶” μ‹¬κΈ°
    solve()

```

## ν•΄μ„¤ 2

BFS μ΄μ©. DFSμ™€ κ±°μ λ™μΌ

---

## CODE 3

```python
import sys
from collections import deque

input = sys.stdin.readline


# ν’€μ΄
def solve():
    global N, M, g

    def bfs(sx, sy):
        que = deque([(sx, sy)])
        v[sx][sy] = True
        dx = (-1, 0, 1, 0)
        dy = (0, 1, 0, -1)
        while que:
            cx, cy = que.popleft()
            for i in range(4):
                nx = cx + dx[i]
                ny = cy + dy[i]
                if 0 <= nx < N and 0 <= ny < M and g[nx][ny] == 1 and not v[nx][ny]:
                    que.append((nx, ny))
                    v[nx][ny] = True
        return

    ans = 0
    v = [[False] * M for _ in range(N)]
    for x in range(N):
        for y in range(M):
            if g[x][y] == 1 and not v[x][y]:
                bfs(x, y)
                ans += 1
    print(ans)
    return


for test_case in range(int(input())):
    M, N, K = map(int, input().split())
    g = [[0] * M for _ in range(N)]
    for _ in range(K):
        X, Y = map(int, input().split())
        g[Y][X] = 1
    solve()

```

## ν•΄μ„¤ 3

`34192KB`, `76ms`

---

## CODE 4

```python
import sys
from collections import deque

input = sys.stdin.readline


def bfs(sx, sy):
    global N, M, g, v
    que = deque([(sx, sy)])
    v[sx][sy] = True
    dx, dy = (-1, 0, 1, 0), (0, 1, 0, -1)
    while que:
        cx, cy = que.popleft()
        for i in range(4):
            nx, ny = cx + dx[i], cy + dy[i]
            if 0 <= nx < N and 0 <= ny < M and g[nx][ny] == 1 and not v[nx][ny]:
                que.append((nx, ny))
                v[nx][ny] = True
    return


for test_case in range(int(input())):
    M, N, K = map(int, input().split())
    g = [[0] * M for _ in range(N)]
    for _ in range(K):
        X, Y = map(int, input().split())
        g[Y][X] = 1
    v = [[False] * M for _ in range(N)]
    cnt = 0
    for x in range(N):
        for y in range(M):
            if g[x][y] == 1 and not v[x][y]:
                bfs(x, y)
                cnt += 1
    print(cnt)

```

## ν•΄μ„¤ 4

BFS νμ = μ§€λ μ΄ μ

`34192KB`, `76ms`

---

## CODE 5

```python
import sys
input = sys.stdin.readline
#


def dfs(sx, sy):
    global N, M, MAP, v
    dx, dy = (-1, 1, 0, 0), (0, 0, -1, 1)
    stk = [(sx, sy)]
    v[sx][sy] = True
    while stk:
        cx, cy = stk.pop()
        for i in range(4):
            nx, ny = cx + dx[i], cy + dy[i]
            if 0 <= nx < N and 0 <= ny < M and MAP[nx][ny] == 1 and not v[nx][ny]:
                stk.append((nx, ny))
                v[nx][ny] = True
    return


for test_case in range(int(input())):
    M, N, K = map(int, input().split())
    MAP = [[0] * M for _ in range(N)]
    for _ in range(K):
        X, Y = map(int, input().split())
        MAP[Y][X] = 1
    v = [[False] * M for _ in range(N)]
    cnt = 0
    for x in range(N):
        for y in range(M):
            if MAP[x][y] == 1 and not v[x][y]:
                dfs(x, y)
                cnt += 1
    print(cnt)

```

## ν•΄μ„¤ 5

`31256KB`, `52ms`

---

## CODE 6

```python
import sys

input = sys.stdin.readline


# DFS
def dfs(sx, sy, visited):
    global n, m, graph
    dx, dy = (-1, 1, 0, 0), (0, 0, -1, 1)
    stk = [(sx, sy)]
    visited[sx][sy] = True
    while stk:
        cx, cy = stk.pop()
        for i in range(4):
            nx, ny = cx + dx[i], cy + dy[i]
            if 0 <= nx < n and 0 <= ny < m and graph[nx][ny] == 1 and not visited[nx][ny]:
                stk.append((nx, ny))
                visited[nx][ny] = True
    return


def get_earthworm():
    global n, m, graph
    cnt = 0
    visited = [[False] * m for _ in range(n)]
    for x in range(n):
        for y in range(m):
            if graph[x][y] == 1 and not visited[x][y]:
                cnt += 1
                dfs(x, y, visited)  # DFS
    return cnt


# TEST CASE
for test_case in range(int(input())):
    # INPUT
    m, n, k = map(int, input().split())
    graph = [[0] * m for _ in range(n)]
    for _ in range(k):
        x, y = map(int, input().split())
        graph[y][x] = 1
    # ANSWER
    ans = get_earthworm()
    print(ans)

```

## ν•΄μ„¤ 6

`31256KB`, `52ms`

---

## CODE 7

```python
import sys

input = sys.stdin.readline


def dfs(n, m, graph, v, sx, sy):
    dx, dy = (-1, 1, 0, 0), (0, 0, -1, 1)
    stk = [(sx, sy)]
    v[sx][sy] = True
    while stk:
        cx, cy = stk.pop()
        for i in range(4):
            nx, ny = cx + dx[i], cy + dy[i]
            if 0 <= nx < n and 0 <= ny < m and graph[nx][ny] == 1 and not v[nx][ny]:
                stk.append((nx, ny))
                v[nx][ny] = True
    return


def get_ans(n, m, graph):
    cnt = 0
    v = [[False] * m for _ in range(n)]
    for x in range(n):
        for y in range(m):
            if graph[x][y] == 1 and not v[x][y]:
                cnt += 1
                dfs(n, m, graph, v, x, y)
    return cnt


for test_case in range(int(input())):
    m, n, k = map(int, input().split())
    graph = [[0] * m for _ in range(n)]
    for _ in range(k):
        x, y = map(int, input().split())
        graph[y][x] = 1

    ans = get_ans(n, m, graph)
    print(ans)

```

## ν•΄μ„¤ 7

`31256KB`, `56ms`
