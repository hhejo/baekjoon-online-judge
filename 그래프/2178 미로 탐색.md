# 2178 미로 탐색

---

### CODE

```python
import sys
from collections import deque


# 풀이
def solve():
    global N, M, arr  # N, M, 미로

    # bfs
    def bfs():
        que = deque([(0, 0)])  # 큐
        # 큐가 빌 때까지
        while que:
            cx, cy = que.popleft()  # 현재 위치
            # 현재 위치가 도착 지점이면 현재 위치까지 지난 최소의 칸 수 리턴
            if cx == N - 1 and cy == M - 1:
                return arr[cx][cy]
            # 아니라면 현재 위치의 상 우 하 좌에 대해
            for nx, ny in ((cx - 1, cy), (cx, cy + 1), (cx + 1, cy), (cx, cy - 1)):
                # 범위 내에 있고 이동할 수 있는 칸이라면 큐에 넣고 이동할 위치 방문 처리
                # 현재 위치까지 이동한 칸 수 + 1
                if 0 <= nx < N and 0 <= ny < M and arr[nx][ny] == 1:
                    que.append((nx, ny))
                    arr[nx][ny] = arr[cx][cy] + 1
        return

    ans = bfs()  # (N, M)의 위치로 이동하는 최소의 칸 수
    print(ans)
    return


N, M = map(int, input().split())  # N, M
arr = [list(map(int, input())) for _ in range(N)]  # 미로

solve()  # 풀이

```

### 해설

최단거리를 큐를 이용해서 BFS로 구현한다. 방문 여부 배열은 굳이 사용하지 않아도 풀 수 있다.
