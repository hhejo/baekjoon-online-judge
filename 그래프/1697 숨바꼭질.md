# 1697 숨바꼭질



### 접근 방법

BFS를 이용했다.

한 숫자에 대해 가능한 연산이 3가지가 있다. 연산을 적용하려면 연산이 적용된 결과가 유효 범위 내에 있어야 하고, 이전에 나온 적 없는 값이어야 한다.

### CODE

```python
from collections import deque


def bfs(n, k):
    visited = [0] * 100_001
    q = deque([n])
    while q:
        num = q.popleft()
        if k == num:
            return visited[num]
        for tmp in (num - 1, num + 1, num * 2):
            if 0 <= tmp <= 100_000 and not visited[tmp]:
                q.append(tmp)
                visited[tmp] = visited[num] + 1


N, K = map(int, input().split())
ans = bfs(N, K)
print(ans)
```

### 해설

