# [2206 ë²½ ë¶€ìˆ˜ê³  ì´ë™í•˜ê¸°](https://www.acmicpc.net/problem/2206)

### ğŸ¥‡ 3

### ë¶„ë¥˜

- ê·¸ë˜í”„ ì´ë¡ 
- ê·¸ë˜í”„ íƒìƒ‰
- ë„ˆë¹„ ìš°ì„  íƒìƒ‰

### í’€ì´ ë‚ ì§œ

- 230320 ì›”
- 230403 ì›”
- 230619 ì›”
- 230630 ê¸ˆ

---

## CODE 1

```python
import sys
from collections import deque

input = sys.stdin.readline

N, M = map(int, input().split())
g = [list(map(int, input().strip())) for _ in range(N)]


# í’€ì´
def solve():
    global N, M, g

    def bfs(sx, sy):
        que = deque([(sx, sy, 1)])
        v = [[[0, 0] for _ in range(M)] for _ in range(N)]
        v[sx][sy][1] = 1
        while que:
            cx, cy, wall = que.popleft()
            if cx == N - 1 and cy == M - 1:
                return v[cx][cy][wall]
            for nx, ny in ((cx - 1, cy), (cx, cy + 1), (cx + 1, cy), (cx, cy - 1)):
                if 0 <= nx < N and 0 <= ny < M:
                    if g[nx][ny] == 1 and wall == 1:
                        que.append((nx, ny, 0))
                        v[nx][ny][0] = v[cx][cy][1] + 1
                    elif g[nx][ny] == 0 and v[nx][ny][wall] == 0:
                        que.append((nx, ny, wall))
                        v[nx][ny][wall] = v[cx][cy][wall] + 1
        return -1

    ans = bfs(0, 0)
    print(ans)
    return


solve()

```

## í•´ì„¤ 1

ë²½ ë¶€ìˆ  ìˆ˜ ìˆëŠ”ì§€ íŒŒì•…í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•˜ë‹¤.

ë°©ë¬¸ ì—¬ë¶€ ê²¸ ìµœë‹¨ê±°ë¦¬ë¥¼ ì €ì¥í•œ ë°°ì—´ì„ 3ì°¨ì›ìœ¼ë¡œ ë§Œë“¤ì–´ì„œ ì €ì¥í–ˆë‹¤.

ë²½ì´ê³  ë¶€ìˆ  ìˆ˜ ìˆìœ¼ë©´ ë¶€ìˆ˜ê³  ì§„í–‰í•œë‹¤.

ë²½ì´ ì•„ë‹ˆê³  ë°©ë¬¸í•˜ì§€ ì•Šì•˜ìœ¼ë©´ ì§„í–‰í•œë‹¤.

`190988KB`, `3864ms`

---

## CODE 2

```python
import sys
from collections import deque

input = sys.stdin.readline


N, M = map(int, input().split())
g = [list(map(int, input().rstrip())) for _ in range(N)]


def bfs(sx, sy):
    global N, M, g
    que = deque([(sx, sy, 1)])
    v = [[[0, 0] for _ in range(M)] for _ in range(N)]
    v[sx][sy][1] = 1
    dx, dy = (-1, 0, 1, 0), (0, 1, 0, -1)
    while que:
        cx, cy, wall = que.popleft()
        if cx == N - 1 and cy == M - 1:
            return v[cx][cy][wall]
        for i in range(4):
            nx, ny = cx + dx[i], cy + dy[i]
            if 0 <= nx < N and 0 <= ny < M:
                if g[nx][ny] == 1 and wall == 1:
                    que.append((nx, ny, 0))
                    v[nx][ny][0] = v[cx][cy][1] + 1
                elif g[nx][ny] == 0 and not v[nx][ny][wall]:
                    que.append((nx, ny, wall))
                    v[nx][ny][wall] = v[cx][cy][wall] + 1
    return -1


ans = bfs(0, 0)
print(ans)

```

## í•´ì„¤ 2

ë²½ ë¶€ìˆ  ìˆ˜ ìˆìœ¼ë©´ -> ë¶€ìˆ˜ê³  ì§„í–‰

ë²½ ë¶€ìˆ  ìˆ˜ ì—†ìœ¼ë©´ -> ë²½ì´ ì•„ë‹ˆê³  ë°©ë¬¸í•˜ì§€ ì•Šì•˜ìœ¼ë©´ ì§„í–‰

`191116KB`, `3828ms`

---

## CODE 3

```python
import sys
from collections import deque

input = sys.stdin.readline


def bfs(n, m, graph):
    dx, dy = (-1, 1, 0, 0), (0, 0, -1, 1)
    que = deque([(0, 0, 0)])
    v = [[[-1] * 2 for _ in range(m)] for _ in range(n)]
    v[0][0][0] = 0
    while que:
        cx, cy, wall = que.popleft()
        if cx == n - 1 and cy == m - 1:
            return v[cx][cy][wall] + 1
        for i in range(4):
            nx, ny = cx + dx[i], cy + dy[i]
            if 0 <= nx < n and 0 <= ny < m:
                if graph[nx][ny] == 1 and wall == 0:
                    que.append((nx, ny, 1))
                    v[nx][ny][1] = v[cx][cy][0] + 1
                if graph[nx][ny] == 0 and v[nx][ny][wall] == -1:
                    que.append((nx, ny, wall))
                    v[nx][ny][wall] = v[cx][cy][wall] + 1
    return -1


n, m = map(int, input().split())
graph = [list(map(int, input().rstrip())) for _ in range(n)]
ans = bfs(n, m, graph)
print(ans)

```

## í•´ì„¤ 3

`191056KB`, `3756ms`

---

## CODE 4

```python
import sys
from collections import deque

input = sys.stdin.readline


def bfs(sx, sy, gx, gy):
    global n, m, graph
    dx, dy = (-1, 1, 0, 0), (0, 0, -1, 1)
    que = deque([(sx, sy, 0)])
    v = [[[0] * 2 for _ in range(m)] for _ in range(n)]
    v[sx][sy][0] = 1
    while que:
        cx, cy, w = que.popleft()
        if cx == gx and cy == gy:
            return v[cx][cy][w]
        for i in range(4):
            nx, ny = cx + dx[i], cy + dy[i]
            if 0 <= nx < n and 0 <= ny < m and v[nx][ny][w] == 0:
                if graph[nx][ny] == 1 and w == 0:
                    que.append((nx, ny, 1))
                    v[nx][ny][1] = v[cx][cy][0] + 1
                elif graph[nx][ny] == 0:
                    que.append((nx, ny, w))
                    v[nx][ny][w] = v[cx][cy][w] + 1
    return -1


n, m = map(int, input().split())
graph = [list(map(int, input().rstrip())) for _ in range(n)]

ans = bfs(0, 0, n - 1, m - 1)
print(ans)

```

## í•´ì„¤ 4

`188964KB`, `3900ms`
