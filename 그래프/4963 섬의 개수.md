# [4963 ì„¬ì˜ ê°œìˆ˜](https://www.acmicpc.net/problem/4963)

### ğŸ¥ˆ 2

### ë¶„ë¥˜

- ê·¸ë˜í”„ ì´ë¡ 
- ê·¸ë˜í”„ íƒìƒ‰
- ë„ˆë¹„ ìš°ì„  íƒìƒ‰
- ê¹Šì´ ìš°ì„  íƒìƒ‰

### í’€ì´ ë‚ ì§œ

- 230217 ê¸ˆ
- 230306 ì›”
- 230319 ì¼
- 230404 í™”
- 230619 ì›”

---

## CODE 1

```python
import sys

input = sys.stdin.readline


# í’€ì´
def solve():
    global W, H, arr

    # DFS
    def dfs(x, y):
        stk = [(x, y)]  # ìŠ¤íƒì— í‘¸ì‹œ
        visited[x][y] = True  # ë°©ë¬¸ ì²˜ë¦¬
        # ë°˜ë³µ
        while stk:
            cx, cy = stk.pop()  # í˜„ì¬ ì¢Œí‘œ
            # ì‹œê³„ë°©í–¥ìœ¼ë¡œ ë‹¤ìŒ ì´ë™í•  ìœ„ì¹˜ ë°˜ë³µ
            for nx, ny in ((cx - 1, cy), (cx - 1, cy + 1), (cx, cy + 1), (cx + 1, cy + 1), (cx + 1, cy), (cx + 1, cy - 1), (cx, cy - 1), (cx - 1, cy - 1)):
                # ìœ íš¨ ë²”ìœ„, ë•…, ë°©ë¬¸í•˜ì§€ ì•ŠìŒ
                if 0 <= nx < H and 0 <= ny < W and arr[nx][ny] == 1 and not visited[nx][ny]:
                    stk.append((nx, ny))  # ìŠ¤íƒì— í‘¸ì‹œ
                    visited[nx][ny] = True  # ë°©ë¬¸ ì²˜ë¦¬
        return

    cnt = 0  # ì„¬ì˜ ê°œìˆ˜
    visited = [[False] * W for _ in range(H)]  # ë°©ë¬¸ ì—¬ë¶€
    # ëª¨ë“  ì¢Œí‘œì— ëŒ€í•´ DFS
    for sx in range(H):
        for sy in range(W):
            # ë•…, ë°©ë¬¸í•˜ì§€ ì•ŠìŒ -> DFS, ì„¬ ê°œìˆ˜ ì¦ê°€
            if arr[sx][sy] == 1 and not visited[sx][sy]:
                dfs(sx, sy)
                cnt += 1
    # ì •ë‹µ ì¶œë ¥
    print(cnt)
    return


# ì…ë ¥
while True:
    W, H = map(int, input().split(' '))  # ë„ˆë¹„, ë†’ì´
    # 0 0ì´ë©´ ì¢…ë£Œ
    if W == H == 0:
        break
    arr = [list(map(int, input().split(' '))) for _ in range(H)]  # ì§€ë„
    # í’€ì´
    solve()

```

## í•´ì„¤ 1

DFS

ëŒ€ê°ì„ ìœ¼ë¡œë„ ê°ˆ ìˆ˜ ìˆìŒì— ì£¼ì˜

`31256KB`, `56ms`

---

## CODE 2

```python
import sys

input = sys.stdin.readline


# í’€ì´
def solve():
    global W, H, MAP

    def dfs(sx, sy):
        stk = [(sx, sy)]
        visited[sx][sy] = True
        while stk:
            cx, cy = stk.pop()
            for nx, ny in ((cx - 1, cy), (cx - 1, cy + 1), (cx, cy + 1), (cx + 1, cy + 1), (cx + 1, cy), (cx + 1, cy - 1), (cx, cy - 1), (cx - 1, cy - 1)):
                if 0 <= nx < H and 0 <= ny < W and MAP[nx][ny] == 1 and not visited[nx][ny]:
                    stk.append((nx, ny))
                    visited[nx][ny] = True
        return

    cnt = 0  # ì„¬ì˜ ê°œìˆ˜
    visited = [[False] * W for _ in range(H)]

    for x in range(H):
        for y in range(W):
            if MAP[x][y] == 1 and not visited[x][y]:
                dfs(x, y)
                cnt += 1

    print(cnt)
    return


# í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ ì…ë ¥
while True:
    W, H = map(int, input().split())
    if W == H == 0:
        break
    MAP = [list(map(int, input().split())) for _ in range(H)]
    # í’€ì´
    solve()

```

## í•´ì„¤ 2

DFSë¡œ ë‹¤ì‹œ í’€ì´

`31256KB`, `56ms`

---

## CODE 3

```python
import sys

input = sys.stdin.readline


# í’€ì´
def solve():
    global W, H, g

    def dfs(sx, sy):
        stk = [(sx, sy)]
        v[sx][sy] = True
        dx = (-1, -1, 0, 1, 1, 1, 0, -1)
        dy = (0, 1, 1, 1, 0, -1, -1, -1)
        while stk:
            cx, cy = stk.pop()
            for i in range(8):
                nx = cx + dx[i]
                ny = cy + dy[i]
                if 0 <= nx < H and 0 <= ny < W and g[nx][ny] == 1 and not v[nx][ny]:
                    stk.append((nx, ny))
                    v[nx][ny] = True
        return

    ans = 0
    v = [[False] * W for _ in range(H)]
    for x in range(H):
        for y in range(W):
            if g[x][y] == 1 and not v[x][y]:
                dfs(x, y)
                ans += 1
    print(ans)
    return


while True:
    W, H = map(int, input().split())
    if W == H == 0:
        break
    g = [list(map(int, input().split())) for _ in range(H)]
    solve()

```

## í•´ì„¤ 3

ìŠ¤íƒ ì‚¬ìš© DFS

`31256KB`, `56ms`

---

## CODE 4

```python
import sys

input = sys.stdin.readline
sys.setrecursionlimit(10 ** 6)


# í’€ì´
def solve():
    global W, H, g
    dx = (-1, -1, 0, 1, 1, 1, 0, -1)
    dy = (0, 1, 1, 1, 0, -1, -1, -1)

    def dfs(cx, cy):
        for i in range(8):
            nx = cx + dx[i]
            ny = cy + dy[i]
            if 0 <= nx < H and 0 <= ny < W and g[nx][ny] == 1 and not v[nx][ny]:
                v[nx][ny] = True
                dfs(nx, ny)
        return

    ans = 0
    v = [[False] * W for _ in range(H)]
    for x in range(H):
        for y in range(W):
            if g[x][y] == 1 and not v[x][y]:
                v[x][y] = True
                dfs(x, y)
                ans += 1
    print(ans)
    return


while True:
    W, H = map(int, input().split())
    if W == H == 0:
        break
    g = [list(map(int, input().split())) for _ in range(H)]
    solve()

```

## í•´ì„¤ 4

ì¬ê·€ DFS

`31668KB`, `60ms`

---

## CODE 5

```python
import sys

sys.setrecursionlimit(10 ** 6)
input = sys.stdin.readline


def dfs(x, y, v):
    global W, H, g, dx, dy
    for i in range(8):
        nx, ny = x + dx[i], y + dy[i]
        if 0 <= nx < H and 0 <= ny < W and g[nx][ny] == 1 and not v[nx][ny]:
            v[nx][ny] = True
            dfs(nx, ny, v)
    return


dx, dy = (-1, -1, 0, 1, 1, 1, 0, -1), (0, 1, 1, 1, 0, -1, -1, -1)
while True:
    W, H = map(int, input().split())
    if W == H == 0:
        break
    g = [list(map(int, input().split())) for _ in range(H)]
    v = [[0] * W for _ in range(H)]
    cnt = 0
    for x in range(H):
        for y in range(W):
            if g[x][y] == 1 and not v[x][y]:
                dfs(x, y, v)
                cnt += 1
    print(cnt)

```

## í•´ì„¤ 5

ìƒí•˜ì¢Œìš° ë§ê³ ë„ ëŒ€ê°ì„ ìœ¼ë¡œë„ ì›€ì§ì¼ ìˆ˜ ìˆìœ¼ë‹ˆ ì£¼ì˜

`31620KB`, `60ms`

---

## CODE 6

```python
import sys

input = sys.stdin.readline


def dfs(sx, sy, graph, v):
    dx, dy = (-1, -1, 0, 1, 1, 1, 0, -1), (0, 1, 1, 1, 0, -1, -1, -1)
    stk = [(sx, sy)]
    v[sx][sy] = True
    while stk:
        cx, cy = stk.pop()
        for i in range(8):
            nx, ny = cx + dx[i], cy + dy[i]
            if 0 <= nx < h and 0 <= ny < w and graph[nx][ny] == 1 and not v[nx][ny]:
                stk.append((nx, ny))
                v[nx][ny] = True
    return


def get_count(w, h, graph):
    v = [[False] * w for _ in range(h)]
    cnt = 0
    for x in range(h):
        for y in range(w):
            if graph[x][y] == 1 and not v[x][y]:
                cnt += 1
                dfs(x, y, graph, v)
    return cnt


while True:
    w, h = map(int, input().split())
    if w == h == 0:
        break
    graph = [list(map(int, input().split())) for _ in range(h)]
    ans = get_count(w, h, graph)
    print(ans)

```

## í•´ì„¤ 6

`31256KB`, `56ms`
