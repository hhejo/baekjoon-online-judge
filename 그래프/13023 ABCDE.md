# 13023 ABCDE



## 1.

### 접근 방법

모든 원소에 대해 DFS를 각각 수행한다. 중요한 것은 `visited` 2차원 리스트가 방문 처리 역할을 하는데, 한 정점에 대해 DFS를 수행하고 다음 정점에서 DFS를 수행하기 전에 `visited`의 값을 초기화해야 한다.

### CODE

```python
import sys

input = sys.stdin.readline


def dfs(now, cnt):
    global N, ADJ, visited, ans
    if 4 == cnt:
        ans = 1
        return
    for v in ADJ[now]:
        if not visited[v]:
            visited[v] = 1
            dfs(v, cnt + 1)
            visited[v] = 0


N, M = map(int, input().split())
ADJ = [[] for _ in range(N)]
for _ in range(M):
    A, B = map(int, input().split())
    ADJ[A].append(B)
    ADJ[B].append(A)
visited = [0] * N
ans = 0
for i in range(N):
    if ans:
        break
    visited[i] = 1
    dfs(i, 0)
    visited[i] = 0
print(ans)
```

### 해설

인접 리스트로 양방향 연결. DFS 탐색이 4번째라면 정답



## 2.

### CODE

```python
import sys

input = sys.stdin.readline


def dfs(c, cnt):
    global ADJ, visited, ans
    visited[c] = True
    if 4 == cnt:
        ans = 1
        return
    for v in ADJ[c]:
        if not visited[v]:
            dfs(v, cnt + 1)
    visited[c] = False
    return


N, M = map(int, input().split())
ADJ = [[] for _ in range(N)]
for _ in range(M):
    A, B = map(int, input().split())
    ADJ[A].append(B)
    ADJ[B].append(A)
visited = [False] * N
ans = 0
for i in range(N):
    if ans:
        break
    dfs(i, 0)
print(ans)
```

### 해설

1번 개선. 방문 처리 작업을 dfs() 함수 안에서 처리

